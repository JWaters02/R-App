print(get_series_date_extremes(get_series_names()[1], get_frequency_types(get_series_names()[1]))[2,1])
runApp()
get_series_date_extremes(get_series_names()[1], get_frequency_types(get_series_names()[1]))[1, 1]
get_series_sources(input$trendType)$SourceLink
get_series_sources(get_series_names()[1])$SourceLink
get_series_sources(get_series_names()[1])$SourceName
runApp()
runApp()
runApp()
runApp()
View(total_df)
min <- get_series_date_extremes(get_series_names()[1], get_frequency_types(get_series_names()[1]))[1, 1]
datasets_df <- select(filter(filter(total_df, SeriesName == seriesName), Frequency == frequency), Date)
# Generates a vector of the first and last row of the date column of the series name and frequency specified
get_series_date_extremes <- function(seriesName, frequency) {
datasets_df <- select(filter(filter(total_df, SeriesName == seriesName), Frequency == frequency), Date)
min <- head(datasets_df, 1)
max <- tail(datasets_df, 1)
return(bind_rows(min, max))
}
get_series_date_extremes('GDP', 'Annual')
##############################
# Loads the data into a form the app requires from the total_df
##############################
# Load libraries
library(tidyverse)
get_series_date_extremes('GDP', 'Annual')
min <- get_series_date_extremes(get_series_names()[1], get_frequency_types(get_series_names()[1]))[1, 1]
min <- as.integer(as.Date(get_series_date_extremes(get_series_names()[1], get_frequency_types(get_series_names()[1]))[1, 1], '%Y'))
min <- as.integer(as.Date(get_series_date_extremes(get_series_names()[1], get_frequency_types(get_series_names()[1]))[1, 1]), '%Y')
min <- as.integer(as.Date(get_series_date_extremes(get_series_names()[1], get_frequency_types(get_series_names()[1]))[1, 1]), '%Y')
min <- as.string(as.Date(get_series_date_extremes(get_series_names()[1], get_frequency_types(get_series_names()[1]))[1, 1]), '%Y')
min <- as.integer(toString(as.Date(get_series_date_extremes(get_series_names()[1], get_frequency_types(get_series_names()[1]))[1, 1]), '%Y'))
get_first_series_date_extremes <- function() {
min <- get_series_date_extremes(get_series_names()[1], get_frequency_types(get_series_names()[1]))[1, 1]
max <- get_series_date_extremes(get_series_names()[1], get_frequency_types(get_series_names()[1]))[2, 1]
return(c(min, max))
}
get_first_series_date_extremes()[1]
get_first_series_date_extremes()[2]
shiny::runApp()
runApp()
min <- as.Date(get_series_date_extremes(get_series_names()[1], get_frequency_types(get_series_names()[1]))[1, 1])
min <- as.Date(get_series_date_extremes(get_series_names()[1], get_frequency_types(get_series_names()[1]))[1, 1], 'GMT')
runApp()
runApp()
min <- get_series_date_extremes(get_series_names()[1], get_frequency_types(get_series_names()[1]))[1, 1]
# Generates a data frame of only the dates and values columns of a specified series name and frequency
get_series_data <- function(seriesName, frequency) {
datasets_df <- select(filter(filter(total_df, SeriesName == seriesName), Frequency == frequency), Date:Value)
return(datasets_df)
}
print(get_series_data('GDP', 'Annual'))
runApp()
# Generates a vector of the first and last row of the date column of the series name and frequency specified
get_series_date_extremes <- function(seriesName, frequency) {
datasets_df <- select(filter(filter(total_df, SeriesName == seriesName), Frequency == frequency), Date)
min <- head(datasets_df, 1)
max <- tail(datasets_df, 1)
return(bind_rows(min, max))
}
get_series_date_extremes('GDP', 'Annual')
str(get_series_date_extremes('GDP', 'Annual'))
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
shiny::runApp('F:/Github Projects/Santander/R-App-mainUpdate')
runApp()
runApp()
print(select(total_df, one_of(c('GDP', 'CPI'))))
print(filter(total_df, SeriesName == c('GDP', 'CPI')))
output <- (filter(total_df, SeriesName == c('GDP', 'CPI')))
show(output)
View(output)
View(total_df)
print(datasets_df <- select(filter(total_df, SeriesName == c('GDP', 'CPI'')), Date:Value))
d
out <- (datasets_df <- select(filter(total_df, SeriesName == c('GDP', 'CPI'')), Date:Value))
yes
gaming
# Generates a data frame of the dates and values from a list of series types
get_series_data_from_list_no_frequency <- function(seriesNames) {
datasets_df <- select(filter(total_df, SeriesName == seriesNames), Date:Value)
return(datasets_df)
}
print(get_series_data_from_list_no_frequency(c('GDP', 'CPI')))
# Generates a data frame of the dates and values from a list of series types
get_series_data_from_list_no_frequency <- function(seriesNames) {
datasets_df <- select(filter(total_df, SeriesName == seriesNames), SeriesName, Date, Value)
return(datasets_df)
}
print(get_series_data_from_list_no_frequency(c('GDP', 'CPI')))
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
# Generates a data frame of the dates and values from a list of series types
get_series_data_from_list_no_frequency <- function(seriesNames) {
datasets_df <- select(filter(total_df, SeriesName == seriesNames), SeriesName, Date, Value)
return(datasets_df)
}
print(get_series_data_from_list_no_frequency(c('GDP', 'CPI')))
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
boxplot()
boxplot(total_df)
boxplot(as.factor(total_df))
boxplot(get_summary_statistics())
boxplot(get_summary_statistics('GDP', 'Annual', TRUE))
boxplot(get_summary_statistics('GDP', 'Annual', FALSE))
boxplot(get_summary_statistics('CPI', 'Annual', FALSE))
boxplot(get_summary_statistics('GDP', 'Annual', FALSE))
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
# Generates a data frame of only the dates and values columns of a specified series name and frequency
get_series_data <- function(seriesName, frequency) {
datasets_df <- select(filter(filter(total_df, SeriesName == seriesName), Frequency == frequency), Date:Value)
return(datasets_df)
}
print(get_series_data('GDP', 'Annual'))
library(tidyverse)
print(get_series_data('GDP', 'Annual'))
# Turns date column of series data to string date
convert_to_string_date_series_data <- function(seriesName, frequency) {
datasets_df <- get_series_data(seriesName, frequency)
return(format(datasets_df[,1], "%Y %m %d"))
}
print(convert_to_string_date_series_data('GDP', 'Annual'))
# Turns date column of series data to string date
convert_to_string_date_series_data <- function(seriesName, frequency) {
datasets_df <- get_series_data(seriesName, frequency)
datasets_df[,1] <- format(datasets_df[,1], "%Y %m %d")
return(datasets_df)
}
print(convert_to_string_date_series_data('GDP', 'Annual'))
shiny::runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
# Generates a data frame of the dates and values from list of series types and frequency
get_series_data_from_list <- function(seriesNames, frequency) {
datasets_df <- select(filter(filter(total_df, SeriesName == seriesNames), Frequency = frequency), SeriesName, Date, Value)
return(datasets_df)
}
runApp()
# COMPARE AND SUMMARIES DATA TAB
# When the input tab is changed
observeEvent(input$tabs, {
observeEvent(input$overviewType, {
if (input$overviewType == 'Compare') {
shinyjs::hide(id = "outputsRow")
} else {
shinyjs::show(id = "outputsRow")
}
})
# COMPARE HANDLING
# When the compare types submit button is pressed
observeEvent(input$compareTypesSubmit, {
# Plot the graph with the selected types
output$compareAndSummaryPlot <- renderPlotly({
isolate({
plot <- plot_line_data(get_series_data_from_list_no_frequency(input$compareTypes),
input$dateSliderCompare, "Value", TRUE)
ggplotly(plot)
})
})
})
# SUMMARY HANDLING
# When the trend type is changed
observeEvent(input$trendTypeSummary, {
# Set up the check box group with values
updateCheckboxGroupInput(session,
inputId = "summaryType",
choices = get_summary_statistics(input$trendTypeSummary, '', FALSE)
)
# When the summary statistic types are changed
output$summaryText <- renderText({
summaries <- paste(input$summaryType, collapse = ", ")
paste("Summaries: ", summaries)
})
output$compareAndSummaryPlot <- renderPlotly({
plot <- plot_box_data(get_series_data_no_frequency(input$trendTypeSummary))
ggplotly(plot)
})
})
})
}
observeEvent(input$trendTypeSummary, {
# Set up the check box group with values
updateCheckboxGroupInput(session,
inputId = "summaryType",
choices = get_summary_statistics(input$trendTypeSummary, '', FALSE)
)
# When the summary statistic types are changed
output$summaryText <- renderText({
summaries <- paste(input$summaryType, collapse = ", ")
paste("Summaries: ", summaries)
})
output$compareAndSummaryPlot <- renderPlotly({
plot <- plot_box_data(get_series_data_no_frequency(input$trendTypeSummary))
ggplotly(plot)
})
})
observeEvent(input$overviewType, {
if (input$overviewType == 'Compare') {
shinyjs::hide(id = "outputsRow")
} else {
shinyjs::show(id = "outputsRow")
}
})
# COMPARE HANDLING
# When the compare types submit button is pressed
observeEvent(input$compareTypesSubmit, {
# Plot the graph with the selected types
output$compareAndSummaryPlot <- renderPlotly({
isolate({
plot <- plot_line_data(get_series_data_from_list_no_frequency(input$compareTypes),
input$dateSliderCompare, "Value", TRUE)
ggplotly(plot)
})
})
})
observeEvent(input$tabs, {
observeEvent(input$overviewType, {
if (input$overviewType == 'Compare') {
shinyjs::hide(id = "outputsRow")
} else {
shinyjs::show(id = "outputsRow")
}
})
# COMPARE HANDLING
# When the compare types submit button is pressed
observeEvent(input$compareTypesSubmit, {
# Plot the graph with the selected types
output$compareAndSummaryPlot <- renderPlotly({
isolate({
plot <- plot_line_data(get_series_data_from_list_no_frequency(input$compareTypes),
input$dateSliderCompare, "Value", TRUE)
ggplotly(plot)
})
})
})
# SUMMARY HANDLING
# When the trend type is changed
observeEvent(input$trendTypeSummary, {
# Set up the check box group with values
updateCheckboxGroupInput(session,
inputId = "summaryType",
choices = get_summary_statistics(input$trendTypeSummary, '', FALSE)
)
# When the summary statistic types are changed
output$summaryText <- renderText({
summaries <- paste(input$summaryType, collapse = ", ")
paste("Summaries: ", summaries)
})
output$compareAndSummaryPlot <- renderPlotly({
plot <- plot_box_data(get_series_data_no_frequency(input$trendTypeSummary))
ggplotly(plot)
})
})
})
# DATA OVERVIEW TAB
# When the trend type is changed
observeEvent(input$trendType, {
# Load in the right radio button options
updateRadioButtons(session,
inputId = "frequency",
choices = get_frequency_types(input$trendType))
output$plotSource <- renderText({
paste0('Source: ', get_series_sources(input$trendType)[2]$SourceName)
})
output$tableSource <- renderText({
paste0('Source: ', get_series_sources(input$trendType)[2]$SourceName)
})
# When the frequency radio selection is changed
observeEvent(input$frequency, {
# Load in the right data slider range
updateSliderInput(session,
inputId = 'dateSlider',
min = year(get_series_date_extremes(input$trendType, input$frequency)[1, 1]),
max = year(get_series_date_extremes(input$trendType, input$frequency)[2, 1]),
value = c(year(get_series_date_extremes(input$trendType, input$frequency)[1, 1]),
year(get_series_date_extremes(input$trendType, input$frequency)[2, 1])))
# Save currently selected min and max values
observe({
val <- input$dateSlider
# Update plot and table on date slider changed
observeEvent(input$dateSlider, {
# Plot
output$linePlot <- renderPlotly({
plot <- plot_line_data(get_series_data(input$trendType, input$frequency),
input$dateSlider, input$trendType, FALSE)
ggplotly(plot)
})
# Table
output$table <- renderTable({
convert_to_string_date_series_data(input$trendType, input$frequency)
}, striped = TRUE, align = "c")
})
})
})
})
runApp()
# COMPARE AND SUMMARIES DATA TAB
# When the input tab is changed
observeEvent(input$tabs, {
observeEvent(input$overviewType, {
if (input$overviewType == 'Compare') {
shinyjs::hide(id = "outputsRow")
} else {
shinyjs::show(id = "outputsRow")
}
})
# COMPARE HANDLING
# When the compare types submit button is pressed
observeEvent(input$compareTypesSubmit, {
# Plot the graph with the selected types
output$compareAndSummaryPlot <- renderPlotly({
isolate({
plot <- plot_line_data(get_series_data_from_list_no_frequency(input$compareTypes),
input$dateSliderCompare, "Value", TRUE)
ggplotly(plot)
})
})
})
# SUMMARY HANDLING
# When the trend type is changed
observeEvent(input$trendTypeSummary, {
# Set up the check box group with values
updateCheckboxGroupInput(session,
inputId = "summaryType",
choices = get_summary_statistics(input$trendTypeSummary, '', FALSE)
)
# When the summary statistic types are changed
output$summaryText <- renderText({
summaries <- paste(input$summaryType, collapse = ", ")
paste("Summaries: ", summaries)
})
output$compareAndSummaryPlot <- renderPlotly({
plot <- plot_box_data(get_series_data_no_frequency(input$trendTypeSummary))
ggplotly(plot)
})
})
})
library(tidyverse)
library(shiny)
# Load total_df
source("src/input_datasets.R")
# Generates a vector of names of the data sets
get_series_names <- function() {
datasets_df <- distinct(select(total_df, SeriesName))
dataset <- datasets_df[,1]
return(dataset)
}
# Generates a vector of frequency names of the series names specified
get_frequency_types <- function(seriesName) {
datasets_df <- filter(total_df, SeriesName == seriesName)
frequency_types <- distinct(select(datasets_df, Frequency))
dataset <- frequency_types[,1]
return(dataset)
}
# Generates the min and max dates of the first data set
get_first_series_date_extremes <- function() {
min <- strtoi(format(get_series_date_extremes(get_series_names()[1], get_frequency_types(get_series_names()[1]))[1, 1], "%Y"))
max <- strtoi(format(get_series_date_extremes(get_series_names()[1], get_frequency_types(get_series_names()[1]))[2, 1], "%Y"))
return(c(min, max))
}
# Generates a vector of the first and last row of the date column of the series name and frequency specified
get_series_date_extremes <- function(seriesName, frequency) {
datasets_df <- select(filter(filter(total_df, SeriesName == seriesName), Frequency == frequency), Date)
min <- head(datasets_df, 1)
max <- tail(datasets_df, 1)
return(bind_rows(min, max))
}
# Generates a data frame of only the dates and values columns of a specified series name and frequency
get_series_data <- function(seriesName, frequency) {
datasets_df <- select(filter(filter(total_df, SeriesName == seriesName), Frequency == frequency), Date:Value)
return(datasets_df)
}
# Turns date column of series data to string date
convert_to_string_date_series_data <- function(seriesName, frequency) {
datasets_df <- get_series_data(seriesName, frequency)
datasets_df[,1] <- format(datasets_df[,1], "%d-%m-%Y")
return(datasets_df)
}
# Generates data frame of dates and values from only series type
get_series_data_no_frequency <- function(seriesName) {
datasets_df <- select(filter(total_df, SeriesName == seriesName), Date:Value)
return(datasets_df)
}
# Generates a data frame of the dates and values from list of series types and frequency
get_series_data_from_list <- function(seriesNames, frequency) {
datasets_df <- select(filter(filter(total_df, SeriesName == seriesNames), Frequency = frequency), SeriesName, Date, Value)
return(datasets_df)
}
# Generates a data frame of the dates and values from a list of series types
get_series_data_from_list_no_frequency <- function(seriesNames) {
datasets_df <- select(filter(total_df, SeriesName == seriesNames), SeriesName, Date, Value)
return(datasets_df)
}
# Gets the source name and link from a specified series
get_series_sources <- function(seriesName) {
sourceLinks_df <- distinct(select(filter(total_df, SeriesName == seriesName), SourceLink))
sourceNames_df <- distinct(select(filter(total_df, SeriesName == seriesName), SourceName))
return(c(sourceLinks_df[1], sourceNames_df[1]))
}
# Gets various summary statistics for specified data
get_summary_statistics <- function(seriesName, frequency = 'Annual', wantsFrequency) {
if (wantsFrequency) {
datasets_df <- select(get_series_data(seriesName, frequency), Value)
} else {
datasets_df <- select(get_series_data_no_frequency(seriesName), Value)
}
quantiles <- quantile(datasets_df[1,], probs = c(.25, .5, .75))
min <- summarise(datasets_df, min(Value))
max <- summarise(datasets_df, max(Value))
mean <- summarise(datasets_df, mean(Value))
median <- summarise(datasets_df, median(Value))
var <- summarise(datasets_df, var(Value))
sd <- summarise(datasets_df, sd(Value))
lq <- quantiles[1]
mq <- quantiles[2]
uq <- quantiles[3]
iqr <- summarise(datasets_df, IQR(Value))
return(c(min, max, mean, median, var, sd, lq, mq, uq, iqr))
}
# Gets the first summary statistic from the first type and frequency of the data frame
get_first_summary_statistics <- function() {
return(get_summary_statistics(get_series_names()[1], get_frequency_types(get_series_names()[1]), TRUE)[1])
}
runApp()
runApp()
runApp()
runApp()
# Gets various summary statistics for specified data
get_summary_statistics <- function(seriesName, frequency = 'Annual', wantsFrequency) {
if (wantsFrequency) {
datasets_df <- select(get_series_data(seriesName, frequency), Value)
} else {
datasets_df <- select(get_series_data_no_frequency(seriesName), Value)
}
quantiles <- quantile(datasets_df[1,], probs = c(.25, .5, .75))
min <- summarise(datasets_df, min(Value))
max <- summarise(datasets_df, max(Value))
mean <- summarise(datasets_df, mean(Value))
median <- summarise(datasets_df, median(Value))
var <- summarise(datasets_df, var(Value))
sd <- summarise(datasets_df, sd(Value))
lq <- quantiles[1]
mq <- quantiles[2]
uq <- quantiles[3]
iqr <- summarise(datasets_df, IQR(Value))
return(c(min, max, mean, median, var, sd, lq, mq, uq, iqr))
}
get_summary_statistics('GDP', 'Annual', FALSE)
get_summary_statistics('GDP', 'Annual', TRUE)
